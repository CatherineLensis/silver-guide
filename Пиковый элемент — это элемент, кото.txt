Пиковый элемент — это элемент, который строго больше своих соседей.

Учитывая целочисленный массив с нулевым индексом nums , найдите пиковый элемент и верните его индекс. Если массив содержит несколько пиков, верните индекс любого из пиков .

Вы можете себе это представить nums[-1] = nums[n] = -∞. Другими словами, элемент всегда считается строго большим, чем сосед, находящийся за пределами массива.

Вы должны написать алгоритм, который работает во O(log n)времени.

 

Пример 1:

Входные данные: nums = [1,2,3,1]
 Выходные данные: 2
 Объяснение: 3 — это пиковый элемент, и ваша функция должна возвращать индексный номер 2.
Пример 2:

Входные данные: nums = [1,2,1,3,5,6,4]
 Выходные данные: 5
 Объяснение: Ваша функция может возвращать либо индексный номер 1, где пиковый элемент равен 2, либо индексный номер 5, где пиковый элемент равен 6.
 

Ограничения:

1 <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1
nums[i] != nums[i + 1]для всех действительны i.
------------------------------------------------------------------------------------------------------------
def findPeakElement(self, nums):
    left = 0
    right = len(nums)-1

    # обрабатываем условие 3
    while left < right-1:
        mid = (left+right)/2
        if nums[mid] > nums[mid+1] and nums[mid] > nums[mid-1]:
            return mid
            
        if nums[mid] < nums[mid+1]:
            left = mid+1
        else:
            right = mid-1
            
    #обрабатываем условие 1 и 2
    return left if nums[left] >= nums[right] else right




если элемент (не самый правый) меньше своего правого соседа, то справа от него должен быть пиковый элемент, потому что элементы справа от него либо
   1. всегда увеличивается -> самый правый элемент — это пик
   2. всегда уменьшается -> самый левый элемент — это пик
   3. сначала увеличивается, затем уменьшается -> точка поворота — это пик
   4. сначала уменьшение, затем увеличение -> самый левый элемент — это пик
Поэтому мы можем найти вершину только на его правых элементах (разрезаем массив вдвое)
   Та же идея применима к тому, что элемент (не самый левый) меньше своего левого соседа.
Условия:
     1. длина массива равна 1 -> вернуть единственный индекс
     2. длина массива равна 2 -> вернуть индекс большего числа
     3. длина массива больше 2 ->
           (1) найти середину, сравнить ее с левым и правым соседями
           (2) вернуть Mid, если nums[mid] больше, чем у обоих соседей
           (3) взять правую половину массива, если nums[mid] меньше правого соседа
           (4) в противном случае возьмите левую половину